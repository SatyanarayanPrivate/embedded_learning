# File I/O #
    - int open (const char *filePath, int flags, mode_t mode)
        - flags: O_RDONLY, O_WRONLY, O_RDWR, O_CREAT, O_NONBLOCK and etc.
        - mode: S_IRWXU, S_IRUSR, S_IWUSR, S_IRWXG and etc.
        - return: On success valid file descriptor, on error -1 with error value errno.

    - int read (int fd, char *buf, size_t len)
        - fd: file descriptor.
        - buf: buffer in which read data stored.
        - len: number of bytes to read.
        - return: 
                - On success return number of bytes read. On error return -1 with error value errno.
                - return 0 indicates EOF.
                - for O_NONBLOCK will return -1 with errno EAGAIN.

    - int write (int fd, const char *buf, int len);
        - return: On success number of bytes written. -1 on error with error errno.

    - int fsync (int fd)
        - return: On success 0 and -1 on failure with error value errno.

    - int fdatasync(int fd)
        - return: On success 0 and -1 on failure with error value errno.

    - int close (int fd)
        - return: On success 0 and -1 on failure with error value errno.

    - off_t lseek (int fd, off_t pos, int origin)
        - pos: +ve or -ve.
        - origin: SEEK_CUR, SEEK_END and SEEK_SET.
        - return: On success new file position and -1 on failure with error value errno.

    - int select (int n, fd_set *readFdSet, fd_set *writeFdSet, fd_set *exceptiionFdSet, struc timeval *timeout);
        - n: value of the highest-valued file descriptor in any set, plus one.
        - readFdSet, writeFdSet, exceptiionFdSet: respected fd sets (array).
        - timeout: pointer to time info. (struct timeval{ long tv_sec; long tv_usec;}).
        - return: number of file descriptors ready for I/O. 0 if timeout occurs. -1 on error with error value errno.
        - frame work:
            fd_set readSet;
            FD_ZERO(&readSet);
            FD_SET(operationalFd, &readSet);
            select(operationalFd + 1, &readSet, NULL, NULL, &timeout);
            if (FD_ISSET(operationalFd, &readSet) != 0)  // non zero if operationalFd is present in readSet
                // read operation on operationalFd
            FD_CLR(operationalFd, &readSet);
    
    - int close (int fd)
        - return: 0 on success. On error, it returns -1, and sets errno appropriately.

# end of FILE I/O #


# Standard I/O
    - FILE *fopen (const char *filePath, const char *mode
        - mode: r, r+, w, w+, a, a+, b (in some architechture).
        - return: FILE pointer On success, NULL on failure with error value errno.
     
    - FILE *fopen(int fd, const char *mode);
        - fd: file descriptor

    - int fclose (FILE *filePtr);
    - int fcloseall (void);
        - return: 0 on success. On error, it returns -1, and sets errno appropriately.
        
    - char *fgets(char *buf, FILE *filePtr);
        - return: On success, buf is returned; on failure, NULL is returned.
        
    - ssize_t fread (char *buf, ssize_t size, ssize_t nr, FILE *filePtr);
        - size, nr: read "size" bytes with "nr" number of times from filePtr.
        - return: Upon success number of times "size" bytes read. EOF or less than nr denotes error using ferror() and feof() identify exact cause.

    - int fputs(const char *buf, FILE *filePtr);
        - return: On success, non negative number; on failure, EOF is returned.
        
    - ssize_t fwrite(const char *buf, ssize_t size, ssize_t nr, FILE *filePtr);
        - size, nr: write "size" bytes with "nr" number of times from filePtr.
        - return: Upon success number of times "size" bytes write. less than nr denotes error.

    - int fseek (FILE *fileptr, long offset, int whence)
        - whence: SEEK_CUR, SEEK_END and SEEK_SET
        - return: 0 on success, -1 on error with value errno.
        
    - int ftell (FILE *filePtr);
        - return: file position on success, -1 on error with value errno.
        
    - int fflush (FILE *stream);
        - return: file position on success, EOF on error with value errno.
        
    - int ferror (FILE *stream);
        - return: non-zero value indicator if any set, otherwise 0
        
    - int feof (FILE *stream);
        - return: non-zero value indicator if any set, otherwise 0
        
    - void clearerr (FILE *stream);
        - clears the error and the EOF indicators for stream.
        
    - int fileno(FILE *stream);
        - return: associated file descriptor.
        
    - int setvbuf (FILE *stream, char *buf, int mode, size_t size);
        - mode: _IONBF, _IOLBF, _IOFBF
        
    - void flockfile (FILE *stream);
    - void funlockfile (FILE *stream);
    - int ftrylockfile (FILE *stream);
        - return: If stream is currently locked return non-zero, If stream is not currently locked return 0.
    
# Advanced File I/O
int readv (int fd, struct iovec *iov, int count);
int writev (int fd, struct iovec *iov, int count);
    - struct iovec { void *iov_base; size_t iov_len;}
    - return: on success return number bytes read/write, should be the sum of all count iov_len values. on error -1 with error value errno.
    
void mmap(void * addr, ssize_t len, int prot, int flag, int fd, off_t offset);
    - addr: memory addr from where mapping has to done, mostly 0.
    - prot: PROT_NONE, PROT_READ, PROT_WRITE and PROT_EXEC.
    - flags: MAP_FIXED, MAP_SHARED, MAP_PRIVATE.
    - fd: file desriptor,
    - offset: file offset, from where file content should load.
    - return: on success return mapped addr, on failure MAP_FAILED and set errno.
    
int munmap(void *addr, ssize_t len);
    - return: on success return 0, -1 on failure and will set errno.
    
void *mremap(void *addr, ssize_t old_size, ssize_t new_size, unsinged long flags);
    - flags: 0 or MREMAP_MAYMOVE: free to move mapping.
    - return: on success pointer to new mapped addr, MAP_FAILED on failure and sets errno.
    
int mprotect (const void *addr, size_t len, int prot);

int msync(void *addr, ssize_t len, int flags);
    - flags: MS_ASYNC: call will return immediately, MS_INVALIDATE: , MS_SYNC: call will not return until all pages are written back to disk.
    

# Process Management
- The Linux kernel tries four executables, in the following order:
    1. /sbin/init : The preferred and most likely location for the init process.
    2. /etc/init : Another likely location for the init process.
    3. /bin/init : A possible location for the init process.
    4  /bin/sh : The location of the Bourne shell, which the kernel tries to run if it fails to find an init process.
- The first of these processes that exists is executed as the init process.
- If all four processes fail to execute, the Linux kernel halts the system with a panic.

int execl (const char *path, const char *arg, ...);
    - list of argument should be NULL terminated.
    - example:
        - execl ("/bin/vi", "vi", "test.txt", NULL);
int execlp (const char *file, const char *arg, ...);
int execle (const char *path, const char *arg, ..., char * const envp[]);
int execv (const char *path, char *const argv[]);
int execvp (const char *file, char *const argv[]);
int execve (const char *filename, char *const argv[], char *const envp[]); 
    - The l and v delineate whether the arguments are provided via a l ist or an array ( v ector).
    - The p denotes that the user's full p ath is searched for the given file.
    - the e notes that a new environment is also supplied for the new process

pid_t fork()
    - return: non-zero in parent process, zero in child process and -1 if any error which sets errno.
pid_t vfork()
    - in child immediately should call to exec functions.

void exit(int status)
int atexit(void (*func) (void));
int on_exit (void (*function)(int, void *), void *arg);

pid_t wait(int *status)
    - return: child pid > 0, or -1 on error.
    
pid_t waitpid (pid_t pid, int *status, int options);
    - pid: <-1: wait for child process whose gid is absulute value as pid, -1: as like wait(), 0: wait for child process whose gid as current process. >0: pid of specific child process.

#  